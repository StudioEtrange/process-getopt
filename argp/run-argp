#!/bin/bash

PROG=$(basename $0)

# initialise defaults (exported so that argp can see them):
export INT=1
export ARRAY=a
export DOUBLE=1
export URL="http://www.promptu.com"

I_R="1-3"
D_R="0.1-4.0"
A_R="a b"
S_R="^foo.*bar$"

# add_opt name  description                         shopt short-arg long-name long-arg type range 
export ARGS="
PROG: $PROG
add_opt BOOLEAN 'a boolean'                         b     ''        bool
add_opt INT     'an integer ($I_R) (default $INT)'  i     units     int       ''       i    '$I_R'
add_opt ARRAY   \"an array ($A_R) (default $ARRAY) - this option has been given a very long description to see what happens to it - it's much better than glib2's goption as it does get formatted nicely.\" a     widgets   array    ''       a    '$A_R'
add_opt STRING  'a string matching regex \"$S_R\"'  s     regex     string    regex    s   '$S_R'
add_opt HIDDEN  ''                                  ''    ''        hidden    things   s
add_opt DOUBLE  'a double ($D_R) (default $DOUBLE)' d     miles     double    miles    f    $D_R
add_opt URL     'a url (default $URL)'              u     url       url       url      u
USAGE:
[--] [args]
Sprog the bracken fest
Spring the flingen dump
"

# or you can: export USAGE="Sprog the bracken fest"

# now call argp:
exec 4>&1 # fd4 is now a copy of fd1 ie stdout
RES=$( echo "$ARGS" | ./argp "$@" 3>&1 1>&4 ) # argp outputs its commands on fd3; help goes to fd1

# $@ now contains just our args, options have been processed and removed:

[ "$RES" ] || exit 0 # probably from --help
echo "RES=$RES"
eval $RES
echo
echo "In $0:"
echo "BOOL=$BOOL"
echo "INT=$INT"
echo "STRING=$STRING"
echo "ARRAY=$ARRAY"
echo "VERBOSE=$VERBOSE"
echo "HIDDEN=$HIDDEN"
echo "DOUBLE=$DOUBLE"
echo "URL=$URL"
echo -n "\$@ ="
for i in "$@"; do echo -n " '$i'"; done
echo
