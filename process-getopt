# -*- shell-script -*-
# Copyright 2008 Bob Hepple
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# http://bhepple.freeshell.org
# $Id: process-getopt,v 1.13 2008/12/09 03:57:22 bhepple Exp $

# A wrapper around getopt.

# It buys you:
# o all the goodness of getopt
# o define options in one central place together with descriptions. 
# o fewer 'magic' and duplicated values in your code
# o Better consistency between the getopt calling parameters, the case
#   statement processing the user's options and the help/man pages
# o less spaghetti in your own code
# o easier to maintain
# o help-page and man-page printing - all from the same data sources
# o checking of option consistency at runtime
# o pretty easy to use
# o portable to OS's without long option support - the help page
#   adapts too

# It's easier to see it in an example than to read an explanation, so 
# look at boilerplate first, and then come back here if you want the 
# explanation. Also see the man page process-getopt(1).
#
# 1. define these:
# PROG=$(basename $0)
# VERSION="1.0"
# SHORT_DESC="one liner for man page"
# ARGUMENTS="foobar barfoo [ files ] [ more-args ]"
# USAGE="\
# usage string - for help page and man page - can be quite long
# "
# usage() {
#    echo "Usage: $PROG [ OPTIONS ] $ARGUMENTS"
#    echo "$USAGE"
#    echo
#    echo "Options:"
# }
#
# 2. 'source' this file 
# PG=$(type process-getopt |cut -d' ' -f 3)
# [ "$PG" ] || exit 1
# . $PG
#
# 3. define a function for each option - call it FOOBAR_func. It is
# called by process_opts if the option is present. It is also called
# by add_opt (with no args) to check that it is there.
# 
# FOOBAR_func() { [ "$1" ] && echo "$PROG: got a FOOBAR option"; }
#
# 4. define your options by calling add_opt as follows:
# add_opt FOOBAR "bars the foo and foos the bar" f "foobar" foo "foobar"
# add_std_opts
# 
# 5. call_getopt like this:
# TEMP=$(call_getopt "$@") || exit 1
# eval set -- "$TEMP"
# unset TEMP
#
# 6. call process_opts like this:
# process_opts "$@"; shift "$?"
#
# 7. $@ now contains all your non-option arguments
#
# Function list:
# --------------
#
# These are the main players: see the code for more doco
#
# add_opt - add an option
# add_std_opts - adds help, verbose, version & print-man-page options
# call_getopt - assembles the option lists and calls getopt
# process_opts - calls your helper functions to process the options

# An internal magic option '--print-man-page' prints a skeleton man page
# using your option definitions and usage

# Note that options are printed out in the order they were defined by
# add_opt - and the 'standard' options follow.

# todo:
# python, c, perl versions of this. ruby? c++? java?

process_getopt_usage() {
    echo "Usage: $PROG [ OPTIONS ]"
    echo
    echo "Normally sourced by other scripts rather than running by itself."
    echo "See the man page for details of functions that $PROG provides."
    echo "When called without options, does nothing. Otherwise:"
    echo
    echo "Options:"
    print_all_opts
    echo "  --$PRINTMAN_loption          print out a man page stub"
}

# make sure our address space is clean - particularly for when we call
# one shell from another and both use process-getopt. Or possibly if
# we're building something like openssl with global-options, commands
# and command-options, eg. openssl -n rsa -b arg arg etc We'd use
# process-getopt with STOP_ON_FIRST_NON_OPT set to process the global
# options then call clean_process_getopt and then use process-getopt
# again to process the command options. 
clean_process_getopt() {
    unset ${!SOPT*} ${!LOPT*} ${!DESC_OPT*} ${!ARG_SOPT*} ${!ARG_LOPT*}
    unset __PG_OPTION_LIST
}

process_getopt_version() {
    echo "$__PG_VERSION"
}

add_opt () {
    # parameters: use "" as the placeholder for a missing arg
    local NAME="$1" ; shift # name of the option - essential
    local DESC="$1" ; shift # essential except for 'silent/secret' options
    local SOPT="$1" ; shift # short option letter - optional
    local SARG="$1" ; shift # argument label for the short option - optional
    local LOPT="$1" ; shift # long option - optional
    local LARG="$1" ; shift # argument label for the long option - optional
    local A
    local L
    local ALLOWED_CHARS='[a-zA-Z0-9_][a-zA-Z0-9_]*'
    local OPT

    [ "$NAME" ] || { 
        echo "$PROG: add_opt requires a name" >&2
        exit 1
    }
    [[ "$NAME" =~ $ALLOWED_CHARS ]] || {
        echo "$PROG: apt_opt: NAME (\"$NAME\") must obey the regexp $ALLOWED_CHARS" >&2
        exit 1
    }

    # check at least a short or a long option is given:
    [ "$SOPT$LOPT" ] || {
        echo "$PROG: add_opt: option $NAME needs a short or a long option" >&2
        exit 1
    }

    # check that a helper function is available:
    ${NAME}$FUNC_SUFFIX 2>/dev/null; local STAT=$?
    if [ $STAT -eq 127 ]; then
        echo "$PROG: option $NAME has no helper function $NAME$FUNC_SUFFIX" >&2
        exit 1
    fi

    # force args to be consistent:
    [ "$LOPT" ] && [ ! "$LARG" ] && LARG="$SARG"
    [ "$SOPT" ] && [ ! "$SARG" ] && SARG="$LARG"

    [ "$SARG$LARG" ] && A="A" || A=""

    # check it's not already in use
    for OPT in $__PG_OPTION_LIST; do 
        if [ "$NAME" = "$OPT" ]; then
            echo "$PROG: option name \"$NAME\" is already in use" >&2
            exit 1
        fi
        # check it's not already in use - cover the case of with and
        # without args:
        if [ "$SOPT" ]; then
            for SUFFIX in "" "A"; do
                L="SOPT${SUFFIX}_$OPT"
                if [ "$SOPT" = "${!L}" ]; then
                    echo "$PROG: short option \"$SOPT\" is already in use by \
$OPT" >&2
                    exit 1
                fi
            done
        fi
        if [ "$LOPT" ]; then
            for SUFFIX in "" "A"; do
                L="LOPT${SUFFIX}_$OPT"
                if [ "$LOPT" = "${!L}" ]; then
                    echo "$PROG: long option \"$LOPT\" is already in use by $OPT" >&2
                    exit 1
                fi
            done
        fi
    done

    if [ "$SOPT" ]; then
        [ ${#SOPT} -ne 1 ] && {
            echo "$PROG: short option \"$SOPT\" for option $NAME is not a \
single character" >&2
            exit 1
        }
        export SOPT${A}_$NAME="$SOPT"
        [ "$SARG" ] && export ARG_SOPTA_$NAME="$SARG"
    fi

    if [ "$LOPT" ]; then
        export LOPT${A}_$NAME="$LOPT"
        [ "$LARG" ] && export ARG_LOPTA_$NAME="$LARG"
    fi

    if [ "$DESC" ]; then
        export DESC_OPT_$NAME="$DESC"
    fi
    __PG_OPTION_LIST="$__PG_OPTION_LIST $NAME"
}

get_opt_letter() {
    local NAME="$1"
    local L="SOPT_$NAME" 
    
    [ "${!L}" ] || L="SOPTA_$NAME"
    echo -n  "${!L}"
}

get_opt_string() {
    local NAME="$1"
    local L="LOPT_$NAME" 
    
    [ "${!L}" ] || L="LOPTA_$NAME"
    echo -n  "${!L}"
}

get_opt_sarg() {
    local NAME="$1"
    local L="ARG_SOPTA_$NAME" 
    
    echo -n "${!L}"
}

get_opt_larg() {
    local NAME="$1"
    local L="ARG_LOPTA_$NAME" 
    
    echo -n "${!L}"
}

get_opt_desc() {
    local NAME="$1"
    local L="DESC_OPT_$NAME" 
    
    echo -n "${!L}"
}

# prints only short options that take no parameter
print_short_flags() {
    local NAME
    local FLAGS=""

    for NAME in $__PG_OPTION_LIST; do
        local DESC=$(get_opt_desc $NAME)
        [ "$DESC" ] || continue
        local L=$(get_opt_letter $NAME)
        [ "$L" ] || continue
        local A=$(get_opt_sarg $NAME)
        [ "$A" ] && continue
        FLAGS="$FLAGS$L"
    done
    echo -n "$FLAGS"
}

# prints only long options that take no parameter
print_long_flags() {
    local NAME
    local FLAGS=""
    local SPACE=""

    for NAME in $__PG_OPTION_LIST; do 
        local DESC=$(get_opt_desc $NAME)
        [ "$DESC" ] || continue
        local L=$(get_opt_string $NAME)
        [ "$L" ] || continue
        local A=$(get_opt_larg $NAME)
        [ "$A" ] && continue
        printf -- "$SPACE--%s" $L
        SPACE=" "
    done
    echo -n "$FLAGS"
}

# prints only short options that take a parameter
print_short_args() {
    local MAN=$1

    local NAME
    for NAME in $__PG_OPTION_LIST; do 
        local DESC=$(get_opt_desc $NAME)
        [ "$DESC" ] || continue
        SARG=$(get_opt_sarg "$NAME")
        [ "$SARG" ] || continue
        SOPT=$(get_opt_letter "$NAME")
        [ "$MAN" ] && FMT='[\\fB\-%s\\fP \\fI%s\\fP]' || FMT="[-%s <%s>]"
        printf -- "$FMT" $SOPT $SARG
    done
    echo -n "$FLAGS"
}

# prints only long options that take a parameter
print_long_args() {
    local MAN=$1

    local NAME
    for NAME in $__PG_OPTION_LIST; do 
        local DESC=$(get_opt_desc $NAME)
        [ "$DESC" ] || continue
        LARG=$(get_opt_larg "$NAME")
        [ "$LARG" ] || continue
        LOPT=$(get_opt_string "$NAME")
        [ "$MAN" ] && FMT='[\\fB\-\-%s\\fP=\\fI%s\\fP]' || FMT="[--%s=<%s>]"
        printf -- "$FMT" $LOPT $LARG
    done
}

# prints short and long options that take a parameter
print_all_args() {
    local MAN=$1

    local NAME
    for NAME in $__PG_OPTION_LIST; do 
        local DESC=$(get_opt_desc $NAME)
        [ "$DESC" ] || continue
        SARG=$(get_opt_sarg "$NAME")
        LARG=$(get_opt_larg "$NAME")
        [ "$SARG$LARG" ] || continue

        SOPT=$(get_opt_letter "$NAME")
        LOPT=$(get_opt_string "$NAME")

        echo -n " ["
        [ "$MAN" ] && FMT='\\fB\-%s\\fP \\fI%s\\fP' || FMT="-%s <%s>"
        [ "$SARG" ] && printf -- "$FMT" $SOPT $SARG
        [ "$SARG" -a "$LARG" ] && echo -n ","
        [ "$MAN" ] && FMT='\\fB\-\-%s\\fP=\\fI%s\\fP' || FMT="--%s=<%s>"
        [ "$LARG" ] && printf -- "$FMT" $LOPT $LARG
        echo -n "]"
    done
}

# print the help line for all options
print_all_opts() {
    local NAME
    for NAME in $__PG_OPTION_LIST; do 
        print_opt $NAME
    done
}

# print the option line for a man page
print_opt_man() {
    local NAME="$1"
    local L
    local DESC
    local SOPT
    local LOPT
    local SARG
    local LARG

    DESC=$(get_opt_desc $NAME)
    [ "$DESC" ] || return 0
    SOPT=$(get_opt_letter $NAME)
    LOPT=$(get_opt_string $NAME)
    SARG=$(get_opt_sarg $NAME)
    LARG=$(get_opt_larg $NAME)

    echo ".TP"
    echo -n ".B "
    # NB 'echo -n "-E"' swallows the -E!! and it has no --
    [ "$SOPT" ] && printf -- '\\fB\-%s\\fP' $SOPT
    [ "$SOPT" ] && [ "$SARG" ] && echo -n " \\fI$SARG\\fR"
    if [ "$__PG_LONG_GETOPT" ]; then
        [ "$SOPT" ] && [ "$LOPT" ] && echo -n ", "
        [ "$LOPT" ] && printf -- '\\fB\-\-%s\\fP' $LOPT
        [ "$LOPT" ] && [ "$LARG" ] && echo -n "\\fI=$LARG\\fR"
    fi
    echo
    echo "$DESC"
}

# Create a skeleton man page - uses these parameters if defined:
# USAGE
# ARGUMENTS
# SHORT_DESC
print_man_page() {
    FLAGS=$(print_short_flags)
    [ "$FLAGS" ] && FLAGS='
.RB "[" \-'$FLAGS' "]"'
    LFLAGS=$(print_long_flags | sed 's/-/\\-/g')
    [ "$LFLAGS" ] && LFLAGS='
[
.B '$LFLAGS'
]'
    ARGS=$(print_all_args man)

    cat <<EOF
.\" $Id: process-getopt,v 1.13 2008/12/09 03:57:22 bhepple Exp $
.TH `echo $PROG|tr '[a-z]' '[A-Z]'` 1 \" -*- nroff -*-
.SH NAME
$PROG \- $SHORT_DESC
.SH SYNOPSIS
.hy 0
.na
.B $PROG$FLAGS$LFLAGS$ARGS
$ARGUMENTS
.ad b
.hy 0
.SH DESCRIPTION
$USAGE
.P
Foobar foobar foobar
.SH OPTIONS
EOF

    local NAME
    for NAME in $__PG_OPTION_LIST; do 
        print_opt_man $NAME
    done

    cat <<EOF
.SH "EXIT STATUS"
.SH "ENVIRONMENT"
.SH "FILES"
.SH "EXAMPLES"
.SH "NOTES"
.SH "BUGS"
.SH "SEE ALSO"
.SH "AUTHOR"
Written by Foo Bar <foobar@foobar.org>
.P
.RB http://foobar.foobar.org/foobar
.SH "COPYRIGHT"
Copyright (c) 2008 Robert Hepple
.br
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
.P
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
.P
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
EOF
}

add_std_opts() {
    add_opt HELP "print this help and exit" $HELP_option "" $HELP_loption
    add_opt VERSION "print version and exit" $VERSION_option "" "$VERSION_loption"
    add_opt VERBOSE "do it verbosely" $VERBOSE_option "" "$VERBOSE_loption"
    add_opt QUIET "do it quietly (negates -$VERBOSE_option)" $QUIET_option "" "$QUIET_loption"
    add_opt PRINT_MAN_PAGE "" "" "" "$PRINTMAN_loption"
    add_opt END_OPTIONS "explicitly ends the options" "-"
}

# Note that this function is called in a sub-shell so variables
# defined here will not be available globally. Also, it's called in
# $(...) so any std out goes to the caller which is probably not a
# good thing.
call_getopt() {
    # ${!prefix*} is bash 2.04 (and posix) but not in sh:
    local SHORT_OPTIONS=""
    local SHORT_OPTIONS_ARG=""
    local LONG_OPTIONS=""
    local LONG_OPTIONS_ARG=""
    local STOP_EARLY=""
    local OPT
    local TEMP

    for OPT in ${!SOPT_*}; do
        [ "${!OPT}" = "-" ] && continue # special case of '--'
        SHORT_OPTIONS="$SHORT_OPTIONS${!OPT}"
    done
    for OPT in ${!SOPTA_*}; do 
        SHORT_OPTIONS_ARG="$SHORT_OPTIONS_ARG${!OPT}:"
    done
    for OPT in ${!LOPT_*}; do 
        [ "$LONG_OPTIONS" ] && LONG_OPTIONS="$LONG_OPTIONS,"
        LONG_OPTIONS="$LONG_OPTIONS${!OPT}"
    done
    for OPT in ${!LOPTA_*}; do 
        [ "$LONG_OPTIONS_ARG" ] && LONG_OPTIONS_ARG="$LONG_OPTIONS_ARG,"
        LONG_OPTIONS_ARG="$LONG_OPTIONS_ARG${!OPT}:"
    done

    [ "$STOP_ON_FIRST_NON_OPT" ] && STOP_EARLY="+"
    if [ "$__PG_LONG_GETOPT" ]; then
        local SHORT_ARGS=""
        local LONG_ARGS=""
        [ -n "$SHORT_OPTIONS$SHORT_OPTIONS_ARG" ] && SHORT_ARGS="-o $STOP_EARLY$SHORT_OPTIONS$SHORT_OPTIONS_ARG"
        [ -n "$LONG_OPTIONS" ] && LONG_ARGS="--long $LONG_OPTIONS"
        [ -n "$LONG_OPTIONS_ARG" ] && LONG_ARGS="$LONG_ARGS --long $LONG_OPTIONS_ARG"
        TEMP=$(getopt $SHORT_ARGS $LONG_ARGS -n "$PROG" -- "$@") || exit 1
    else
        TEMP=$(getopt $SHORT_OPTIONS$SHORT_OPTIONS_ARG "$@") || exit 1
    fi
    
    echo "$TEMP"
}

print_opt() {
    local NAME="$1"
    local L
    local N
    local DESC
    local SOPT
    local LOPT
    local SARG
    local LARG

    DESC=$(get_opt_desc $NAME)
    [ "$DESC" ] || return 0
    SOPT=$(get_opt_letter $NAME)
    LOPT=$(get_opt_string $NAME)
    SARG=$(get_opt_sarg $NAME)
    LARG=$(get_opt_larg $NAME)

    LINE=""
    for (( N=0 ; ${#LINE} < __PG_SHORT_OPT_COL ; N++ )) ; do LINE="$LINE " ; done
    [ "$SOPT" ] && LINE="${LINE}-$SOPT"
    [ "$SOPT" ] && [ "$SARG" ] && LINE="${LINE} $SARG"
    if [ "$__PG_LONG_GETOPT" ]; then
        [ "$SOPT" ] && [ "$LOPT" ] && LINE="$LINE, "
        if [ "$LOPT" ]; then
            [ "$SOPT" ] && LONG_START=$LONG_COL_OPT || LONG_START=$__PG_SHORT_OPT_COL
            for (( N=0 ; ${#LINE} < LONG_START ; N++ )); do 
                LINE="$LINE "
            done
            [ "$LOPT" ] && LINE="${LINE}--$LOPT"
            [ "$LOPT" ] && [ "$LARG" ] && LINE="$LINE=$LARG"
        fi
    fi
    LINE="$LINE "
    while (( ${#LINE} < _PG_OPT_DOC_COL - 1)) ; do LINE="$LINE " ; done
    # NB 'echo "-E"' swallows the -E!! and it has no -- so use printf
    printf -- "%s" "$LINE"
    
    FIRST="FIRST_yes"
    if (( ${#LINE} >= _PG_OPT_DOC_COL )); then
        echo
        FIRST=""
    fi
    local WIDTH=$(( __PG_RMARGIN - _PG_OPT_DOC_COL ))
    if ! type fmt &> /dev/null || [ "$WIDTH" -lt 10 ]; then
        printf -- "%s\n" "$DESC"
        return 0
    fi

    export __PG_INDENT=""
    while (( ${#__PG_INDENT} < _PG_OPT_DOC_COL - 1)); do __PG_INDENT="$__PG_INDENT "; done
    echo "$DESC" |fmt -w "$WIDTH" -s | { 
        while read L; do 
            [ "$FIRST" ] || 
            echo -n "$__PG_INDENT"; FIRST=""; printf -- "%s\n" "$L"
        done 
    }
    unset __PG_INDENT
}

# honour GNU ARGP_HELP_FMT parameter
load_help_fmt() {
    [ "$ARGP_HELP_FMT" ] || return
    OFS="$IFS"
    IFS=','
    set -- $ARGP_HELP_FMT
    IFS="$OFS"
    while [ "$1" ]; do
        case "$1" in
            short-opt-col*)
                __PG_SHORT_OPT_COL=$(echo "$1"|cut -d'=' -f 2)
                shift
                ;;
            long-opt-col*)
                __PG_LONG_OPT_COL=$(echo "$1"|cut -d'=' -f 2)
                shift
                ;;
            opt-doc-col*)
                _PG_OPT_DOC_COL=$(echo "$1"|cut -d'=' -f 2)
                shift
                ;;
            rmargin*)
                __PG_RMARGIN=$(echo "$1"|cut -d'=' -f 2)
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
}

default_usage() {
    local FLAGS=$(print_short_flags)
    [ "$FLAGS" ] && FLAGS="[-$FLAGS]"
    local LFLAGS=$(print_long_flags)
    [ "$LFLAGS" ] && LFLAGS=" [$LFLAGS]"
    local ARGS=$(print_all_args)
    local FMT="fmt -w $__PG_COLUMNS -s"
    type fmt &> /dev/null || FMT=cat
    echo "Usage: $PROG $FLAGS$LFLAGS$ARGS $ARGUMENTS" |$FMT
    echo
    echo "$SHORT_DESC$USAGE" |$FMT
    echo
    echo "Options:"
    print_all_opts
}
    
process_opts() {
    local SHIFT_NUM=0
    while true; do
        case $1 in
        -$HELP_option | --$HELP_loption) 
            usage 2>/dev/null || default_usage
            exit 0
            ;;

        -$VERSION_option | --$VERSION_loption) 
            echo "$PROG: version $VERSION"
            exit 0 
            ;;

        -$VERBOSE_option | --$VERBOSE_loption) 
            VERBOSE="VERBOSE_yes"
            ((SHIFT_NUM++))
            shift
            ;;

        -$QUIET_option | --$QUIET_loption) 
            VERBOSE=""
            ((SHIFT_NUM++))
            shift
            ;;

        --$PRINTMAN_loption)
            print_man_page
            exit 0
            ;;

        --)
            ((SHIFT_NUM++))
            break
            ;;
            
        *) 
            local NAME=$(get_opt_name "$1")
            if [ -z "$NAME" ]; then
                echo "$PROG: process_opts: no function for option \"$1\"" >&2
                exit 1
            fi
            $NAME$FUNC_SUFFIX "$1" "$2"; local STAT=$?
            shift
            ((SHIFT_NUM++))
            [ "$STAT" -eq 127 ] && exit 0 # no such function
            
            # now let's adjust for options with args:
            local SA="ARG_SOPTA_$NAME"
            local LA="ARG_LOPTA_$NAME"
            if [ "${!SA}${!LA}" ]; then
                shift
                ((SHIFT_NUM++))
            fi
            ;;
        esac
    done
    return $SHIFT_NUM
}

get_opt_name() {
    # returns the name for an option letter or word
    local OPT="$1" # an option eg -c or --foobar
    local NAME
    for NAME in $__PG_OPTION_LIST; do 
        local L=LOPT_$NAME
        local LA=LOPTA_$NAME
        local S=SOPT_$NAME
        local SA=SOPTA_$NAME
        if  [ "--${!L}" = "$OPT" ] || \
            [ "--${!LA}" = "$OPT" ] || \
            [ "-${!S}" = "$OPT" ] || \
            [ "-${!SA}" = "$OPT" ]; then
            echo "${NAME}"
            return 0
        fi
    done
    return 1
}

clean_process_getopt

__PG_VERSION="1.3"
__PG_STANDALONE=""

# First some safety checks:
[ "$PROG" ] || { 
    PROG=$(basename $0)
    if [ "$PROG" != "process-getopt" ]; then
        echo "$PROG: \$PROG not defined, bailing" >&2; 
        exit 1; 
    fi
    # Otherwise, we're running as a standalone - perhaps to get the
    # version or help
    VERSION=$__PG_VERSION
    usage() { process_getopt_usage; }
    __PG_STANDALONE="__PG_STANDALONE_yes"
}

[ "$VERSION" ] || { 
    echo "$PROG: \$VERSION not defined, bailing" >&2 
    exit 1
}

__PG_COLUMNS=`tput cols 2>/dev/null` || __PG_COLUMNS=80
(( _PG_COLUMNS--))

__PG_OPTION_LIST=""
__PG_LONG_GETOPT=""
# decide if this getopt supports long options:
getopt --test &>/dev/null; __PG_STAT=$?
[ $__PG_STAT -eq 4 ] && __PG_LONG_GETOPT="__PG_LONG_GETOPT_yes"

HELP_loption="help"
HELP_option="h"
VERBOSE_loption="verbose"
VERBOSE_option="v"
QUIET_option="q"
QUIET_loption="quiet"
VERSION_loption="version"
VERSION_option="V"
PRINTMAN_loption="print-man-page"
FUNC_SUFFIX="_func"

__PG_SHORT_OPT_COL=2
__PG_LONG_OPT_COL=6
_PG_OPT_DOC_COL=29
__PG_RMARGIN=79

# stubs to satisfy add_opt on standard opts:
HELP_func() { :; }
VERBOSE_func() { :; }
QUIET_func() { :; }
VERSION_func() { :; }
PRINT_MAN_PAGE_func() { :; }
END_OPTIONS_func() { :; }

load_help_fmt

[ "$__PG_RMARGIN" -gt "$__PG_COLUMNS" ] && __PG_RMARGIN=$__PG_COLUMNS

# normally, this is called without args - but we can also respond to
# normal options too!
[ "$__PG_STANDALONE" ] && {
    add_std_opts
    TEMP=$(call_getopt "$@") || exit 1
    eval set -- "$TEMP"
    process_opts "$@"
    shift "$?"
}
