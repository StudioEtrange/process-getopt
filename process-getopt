# -*- shell-script -*-
# Copyright 2008-2011 Bob Hepple
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# http://sourceforge.net/projects/process-getopt
# http://process-getopt.sourceforge.net
# http://bhepple.freeshell.org/oddmuse/wiki.cgi/process-getopt

# $Id: process-getopt,v 1.30 2011/04/20 08:15:23 bhepple Exp $

# A wrapper around getopt.

# It buys you:
# o all the goodness of getopt
# o define options in one central place together with descriptions. 
# o fewer 'magic' and duplicated values in your code
# o Better consistency between the getopt calling parameters, the case
#   statement processing the user's options and the help/man pages
# o less spaghetti in your own code
# o easier to maintain
# o help-page and man-page printing - all from the same data sources
# o checking of option consistency at runtime
# o range checking of option values at runtime
# o pretty easy to use
# o portable to OS's without long option support - the help page
#   adapts too

# It's easier to see it in an example than to read an explanation, so
# look at boilerplate first, and then see the man page
# process-getopt(1).

# tested on bash-2.04
# Certainly would not work on plain old sh, csh, ksh ... .

# try and write this test to be legal in sh/bash-1.x:
_PG_GOOD_ENOUGH=""
if [ "x$BASH_VERSION" = "x" -o "x$BASH_VERSINFO" = "x" ]; then
    :
elif [ "${BASH_VERSINFO[0]}" -gt 2 ]; then
    _PG_GOOD_ENOUGH="1"
elif [ "${BASH_VERSINFO[0]}" -eq 2 -a "${BASH_VERSINFO[1]}" -ge 4 ]; then
    _PG_GOOD_ENOUGH="1"
fi
if [ "x$_PG_GOOD_ENOUGH" = "x" ]; then
    echo "This version of the shell does not support process-getopt" >&2
    echo "bash-2.04 or later is required" >&2
    exit 1
fi

process_getopt_usage() {
    echo "Usage: $PROG [ OPTIONS ]"
    echo
    echo "Normally sourced by other scripts rather than run by itself."
    echo "See the man page for details of functions that $PROG provides."
    echo "See http://sourceforge.net/projects/process-getopt"
    echo "See http://process-getopt.sourceforge.net"
    echo "See http://bhepple.freeshell.org/oddmuse/wiki.cgi/process-getopt"
    echo "When called without options, does nothing. Otherwise:"
    echo
    echo "Options:"
    print_all_opts
    echo "  --$PRINTMAN_loption          print out a man page stub"
}

# make sure our address space is clean - particularly for when we call
# one shell from another and both use process-getopt. Or possibly if
# we're building something like openssl with global-options, commands
# and command-options, eg. openssl -n rsa -b arg arg etc We'd use
# process-getopt with STOP_ON_FIRST_NON_OPT set to process the global
# options then call clean_process_getopt and then use process-getopt
# again to process the command options. 
clean_process_getopt() {
    unset ${!SOPT*} ${!LOPT*} ${!DESC_OPT*} ${!ARG_SOPT*} ${!ARG_LOPT*}
    __PG_OPTION_LIST=""
}

process_getopt_version() {
    echo "$__PG_VERSION"
}

add_opt() {
    # parameters: use "" as the placeholder for a missing arg
    local _PG_NAME _PG_DESC SOPT SARG LOPT LARG _PG_TYPE _PG_RANGE
    _PG_NAME="$1" # name of the option - essential
    _PG_DESC="$2" # essential except for 'silent/secret' options
    SOPT="${3:-""}" # short option letter - optional
    SARG="${4:-""}" # argument label for the short option - optional
    LOPT="${5:-""}" # long option - optional
    LARG="${6:-""}" # argument label for the long option - optional
    _PG_TYPE="${7:-""}" # type of the argument - optional
    _PG_RANGE="${8:-""}" # range for the argument - optional
    local A
    local L
    local ALLOWED_CHARS='[a-zA-Z0-9_][a-zA-Z0-9_]*'
    local OPT

    [ "$_PG_NAME" ] || { 
        echo "$PROG: process-getopt: add_opt requires a name" >&2
        exit 1
    }
    # [[ "$_PG_NAME" =~ $ALLOWED_CHARS ]] || { ... this needs bash-3
    [ `echo $_PG_NAME |tr -d '[:alnum:]' |tr -d '[_]'` ] && {
        echo "$PROG: process-getopt: apt_opt: NAME (\"$_PG_NAME\") must obey the regexp $ALLOWED_CHARS" >&2
        exit 1
    }

    # check at least a short or a long option is given:
    [ "$SOPT$LOPT" ] || {
        echo "$PROG: process-getopt: add_opt: option $_PG_NAME needs a short or a long option" >&2
        exit 1
    }

    # check that a helper function is available by calling it without an arg
    # it is supposed to do nothing - but if it is undefined then we get
    # error 127:
    local STAT=0
    ${_PG_NAME}$FUNC_SUFFIX 2>/dev/null || STAT=$?
    if [ $STAT -eq 127 ]; then
        echo "$PROG: process-getopt: option $_PG_NAME has no helper function $_PG_NAME$FUNC_SUFFIX" >&2
        exit 1
    fi

    # force args to be consistent:
    [ "$LOPT" ] && [ ! "$LARG" ] && LARG="$SARG"
    [ "$SOPT" ] && [ ! "$SARG" ] && SARG="$LARG"

    [ "$SARG$LARG" ] && A="A" || A=""

    # check it's not already in use
    for OPT in $__PG_OPTION_LIST; do 
        if [ "$_PG_NAME" = "$OPT" ]; then
            echo "$PROG: process-getopt: option name \"$_PG_NAME\" is already in use" >&2
            exit 1
        fi
        # check it's not already in use - cover the case of with and
        # without args:
        if [ "$SOPT" ]; then
            for SUFFIX in "" "A"; do
                L="SOPT${SUFFIX}_$OPT"
                if [ "$SOPT" = "${!L:-""}" ]; then
                    echo "$PROG: process-getopt: short option \"$SOPT\" is already in use by \
$OPT" >&2
                    exit 1
                fi
            done
        fi
        if [ "$LOPT" ]; then
            for SUFFIX in "" "A"; do
                L="LOPT${SUFFIX}_$OPT"
                if [ "$LOPT" = "${!L:-""}" ]; then
                    echo "$PROG: process-getopt: long option \"$LOPT\" is already in use by $OPT" >&2
                    exit 1
                fi
            done
        fi
    done

    if [ "$SOPT" ]; then
        [ ${#SOPT} -ne 1 ] && {
            echo "$PROG: process-getopt: short option \"$SOPT\" for option $_PG_NAME is not a single character" >&2
            exit 1
        }
        export SOPT${A}_$_PG_NAME="$SOPT"
        [ "$SARG" ] && export ARG_SOPTA_$_PG_NAME="$SARG"
    fi

    if [ "$LOPT" ]; then
        export LOPT${A}_$_PG_NAME="$LOPT"
        [ "$LARG" ] && export ARG_LOPTA_$_PG_NAME="$LARG"
    fi

    if [ "$_PG_DESC" ]; then
        export DESC_OPT_$_PG_NAME="$_PG_DESC"
    fi

	# use a while loop just for the 'break':
	[ "$SARG$LARG" ] && {
		while [ "$_PG_TYPE" ]; do
			case "$_PG_TYPE" in
				i|I)
					[ "x$_PG_RANGE" = x ] && break
					echo "$_PG_RANGE" | egrep -q "$_PG_INT_RANGE_REGEX" && break
					;;
				r|R|f|F)
					[ "x$_PG_RANGE" = x ] && break
					echo "$_PG_RANGE" | egrep -q "$_PG_FLOAT_RANGE_REGEX" && break
					;;
				s|S)
					[ "x$_PG_RANGE" = x ] && break
					echo "" | egrep -q "$_PG_RANGE"
					[ $? -eq 2 ] || break
					;;
				a|A) 
					[ "x$_PG_RANGE" = x ] || break
					;;
				u|U)
					_PG_TYPE=s
					_PG_RANGE="$_PG_URL_REGEX"
					break
					;;
			esac
			echo "$PROG: process-getopt: bad argument type ('$_PG_NAME') or range ('$_PG_RANGE') for option '$_PG_NAME'." |fmt >&2
			exit 1
		done
	}
	export TYPE_$_PG_NAME="$_PG_TYPE"
	export RANGE_$_PG_NAME="$_PG_RANGE"

    __PG_OPTION_LIST="$__PG_OPTION_LIST $_PG_NAME"
}

get_opt_letter() {
    local _PG_NAME="$1"
    local L="SOPT_$_PG_NAME" 
    
    [ "${!L:-""}" ] || L="SOPTA_$_PG_NAME"
    echo -n  "${!L:-""}"
}

get_opt_string() {
    local _PG_NAME="$1"
    local L="LOPT_$_PG_NAME" 
    
    [ "${!L:-""}" ] || L="LOPTA_$_PG_NAME"
    echo -n  "${!L:-""}"
}

get_opt_sarg() {
    local _PG_NAME="$1"
    local L="ARG_SOPTA_$_PG_NAME" 
    
    echo -n "${!L:-""}"
}

get_opt_larg() {
    local _PG_NAME="$1"
    local L="ARG_LOPTA_$_PG_NAME" 
    
    echo -n "${!L:-""}"
}

get_opt_type() {
	local _PG_NAME="$1"
	local T="TYPE_$_PG_NAME"

	echo -n "${!T:-""}"
}

get_opt_range() {
	local _PG_NAME="$1"
	local R="RANGE_$_PG_NAME"

	echo -n "${!R:-""}"
}

get_opt_desc() {
    local _PG_NAME="$1"
    local L="DESC_OPT_$_PG_NAME" 
    
    echo -n "${!L:-""}"
	local _PG_TYPE=$(get_opt_type "$_PG_NAME")
	[ "x$_PG_TYPE" = x ] || {
		echo -n ". Must be of type '$_PG_TYPE'"
		local _PG_RANGE=$(get_opt_range "$_PG_NAME")
		[ "x$_PG_RANGE" = x ] || {
			case "$_PG_TYPE" in
				s|S)
					echo -n " fitting regex '$_PG_RANGE'."
					;;
				*)
					echo -n " in the range '$_PG_RANGE'."
					;;
			esac
		}
	}
}

del_opt() {
    local _PG_NAME
    for _PG_NAME in "$@"; do
        for PRE in SOPT_ SOPTA_ LOPT_ LOPTA_ DESC_OPT_ ARG_LOPTA_ ARG_SOPTA_ TYPE_ RANGE_; do
            local N=$PRE$_PG_NAME
            [ "${!N:-""}" ] && unset $PRE$_PG_NAME
        done
        local OPT_LIST
        OPT_LIST=""
        for OPT in $__PG_OPTION_LIST; do
            [ $OPT = $_PG_NAME ] || OPT_LIST="$OPT_LIST $OPT"
        done
        __PG_OPTION_LIST="$OPT_LIST"
    done
}

# prints only short options that take no parameter
print_short_flags() {
    local _PG_NAME
    local FLAGS=""

    for _PG_NAME in $__PG_OPTION_LIST; do
        local _PG_DESC=$(get_opt_desc $_PG_NAME)
        [ "$_PG_DESC" ] || continue
        local L=$(get_opt_letter $_PG_NAME)
        [ "$L" ] || continue
        local A=$(get_opt_sarg $_PG_NAME)
        [ "$A" ] && continue
        FLAGS="$FLAGS$L"
    done
    echo -n "$FLAGS"
}

# prints only long options that take no parameter
print_long_flags() {
    local _PG_NAME
    local FLAGS=""
    local SPACE=""

    for _PG_NAME in $__PG_OPTION_LIST; do 
        local _PG_DESC=$(get_opt_desc $_PG_NAME)
        [ "$_PG_DESC" ] || continue
        local L=$(get_opt_string $_PG_NAME)
        [ "$L" ] || continue
        local A=$(get_opt_larg $_PG_NAME)
        [ "$A" ] && continue
        printf -- "$SPACE--%s" $L
        SPACE=" "
    done
    echo -n "$FLAGS"
}

# prints only short options that take a parameter
print_short_args() {
    local MAN=$1

    local _PG_NAME
    for _PG_NAME in $__PG_OPTION_LIST; do 
        local _PG_DESC=$(get_opt_desc $_PG_NAME)
        [ "$_PG_DESC" ] || continue
        SARG=$(get_opt_sarg "$_PG_NAME")
        [ "$SARG" ] || continue
        SOPT=$(get_opt_letter "$_PG_NAME")
        [ "$MAN" ] && FMT='[\\fB\-%s\\fP \\fI%s\\fP]' || FMT="[-%s <%s>]"
        printf -- "$FMT" $SOPT $SARG
    done
    echo -n "$FLAGS"
}

# prints only long options that take a parameter
print_long_args() {
    local MAN=$1

    local _PG_NAME
    for _PG_NAME in $__PG_OPTION_LIST; do 
        local _PG_DESC=$(get_opt_desc $_PG_NAME)
        [ "$_PG_DESC" ] || continue
        LARG=$(get_opt_larg "$_PG_NAME")
        [ "$LARG" ] || continue
        LOPT=$(get_opt_string "$_PG_NAME")
        [ "$MAN" ] && FMT='[\\fB\-\-%s\\fP=\\fI%s\\fP]' || FMT="[--%s=<%s>]"
        printf -- "$FMT" $LOPT $LARG
    done
}

# prints short and long options that take a parameter
print_all_args() {
    local MAN=${1:-""}

    local _PG_NAME
    for _PG_NAME in $__PG_OPTION_LIST; do 
        local _PG_DESC=$(get_opt_desc $_PG_NAME)
        [ "$_PG_DESC" ] || continue
        SARG=$(get_opt_sarg "$_PG_NAME")
        LARG=$(get_opt_larg "$_PG_NAME")
        [ "$SARG$LARG" ] || continue

        SOPT=$(get_opt_letter "$_PG_NAME")
        LOPT=$(get_opt_string "$_PG_NAME")

        echo -n " ["
        [ "$MAN" ] && FMT='\\fB\-%s\\fP \\fI%s\\fP' || FMT="-%s <%s>"
        [ "$SARG" ] && printf -- "$FMT" $SOPT $SARG
        [ "$SARG" -a "$LARG" ] && echo -n ","
        [ "$MAN" ] && FMT='\\fB\-\-%s\\fP=\\fI%s\\fP' || FMT="--%s=<%s>"
        [ "$LARG" ] && printf -- "$FMT" $LOPT $LARG
        echo -n "]"
    done
}

# print the help line for all options
print_all_opts() {
    local _PG_NAME
    for _PG_NAME in $__PG_OPTION_LIST; do 
        print_opt $_PG_NAME
    done
}

# print the option line for a man page
print_opt_man() {
    local _PG_NAME="$1"
    local L
    local _PG_DESC
    local SOPT
    local LOPT
    local SARG
    local LARG

    _PG_DESC=$(get_opt_desc $_PG_NAME)
    [ "$_PG_DESC" ] || return 0
    SOPT=$(get_opt_letter $_PG_NAME)
    LOPT=$(get_opt_string $_PG_NAME)
    SARG=$(get_opt_sarg $_PG_NAME)
    LARG=$(get_opt_larg $_PG_NAME)

    echo ".TP"
    echo -n ".B "
    # NB 'echo -n "-E"' swallows the -E!! and it has no --
    [ "$SOPT" ] && printf -- '\\fB\-%s\\fP' $SOPT
    [ "$SOPT" ] && [ "$SARG" ] && echo -n " \\fI$SARG\\fR"
    if [ "$__PG_LONG_GETOPT" ]; then
        [ "$SOPT" ] && [ "$LOPT" ] && echo -n ", "
        [ "$LOPT" ] && printf -- '\\fB\-\-%s\\fP' $LOPT
        [ "$LOPT" ] && [ "$LARG" ] && echo -n "\\fI=$LARG\\fR"
    fi
    echo
    echo "$_PG_DESC"
}

# Create a skeleton man page - uses these parameters if defined:
# USAGE
# ARGUMENTS
# SHORT_DESC
print_man_page() {
    FLAGS=$(print_short_flags)
    [ "$FLAGS" ] && FLAGS='
.RB "[" \-'$FLAGS' "]"'
    LFLAGS=$(print_long_flags | sed 's/-/\\-/g')
    [ "$LFLAGS" ] && LFLAGS='
[
.B '$LFLAGS'
]'
    ARGS=$(print_all_args man)

    cat <<EOF
.TH `echo $PROG|tr '[a-z]' '[A-Z]'` 1 \" -*- nroff -*-
.SH NAME
$PROG \- $SHORT_DESC
.SH SYNOPSIS
.hy 0
.na
.B $PROG$FLAGS$LFLAGS$ARGS
${ARGUMENTS:-""}
.ad b
.hy 0
.SH DESCRIPTION
${USAGE:-""}
.P
Foobar foobar foobar
.SH OPTIONS
EOF

    local _PG_NAME
    for _PG_NAME in $__PG_OPTION_LIST; do 
        print_opt_man $_PG_NAME
    done

    cat <<EOF
.SH "EXIT STATUS"
.SH "ENVIRONMENT"
.SH "FILES"
.SH "EXAMPLES"
.SH "NOTES"
.SH "BUGS"
.SH "SEE ALSO"
.SH "AUTHOR"
Written by Foo Bar <foobar@foobar.org>
.P
.RB http://foobar.foobar.org/foobar
.SH "COPYRIGHT"
Copyright (c) 2008-2011 Robert Hepple
.br
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
.P
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
.P
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
EOF
}

add_std_opts() {
    add_opt HELP "print this help and exit" $HELP_option "" $HELP_loption
    add_opt VERSION "print version and exit" $VERSION_option "" "$VERSION_loption"
    add_opt VERBOSE "do it verbosely" $VERBOSE_option "" "$VERBOSE_loption"
    add_opt QUIET "do it quietly (negates -$VERBOSE_option)" $QUIET_option "" "$QUIET_loption"
    add_opt PRINT_MAN_PAGE "" "" "" "$PRINTMAN_loption"
    add_opt END_OPTIONS "explicitly ends the options" "-"
}

# Note that this function is called in a sub-shell so variables
# defined here will not be available globally. Also, it's called in
# $(...) so any std out goes to the caller which is probably not a
# good thing.
call_getopt() {
    # ${!prefix*} is bash 2.04 (and posix) but not in sh:
    local SHORT_OPTIONS=""
    local SHORT_OPTIONS_ARG=""
    local LONG_OPTIONS=""
    local LONG_OPTIONS_ARG=""
    local STOP_EARLY=""
    local OPT
    local TEMP

    for OPT in ${!SOPT_*}; do
        [ "${!OPT}" = "-" ] && continue # special case of '--'
        SHORT_OPTIONS="$SHORT_OPTIONS${!OPT}"
    done
    for OPT in ${!SOPTA_*}; do 
        SHORT_OPTIONS_ARG="$SHORT_OPTIONS_ARG${!OPT}:"
    done
    for OPT in ${!LOPT_*}; do 
        [ "$LONG_OPTIONS" ] && LONG_OPTIONS="$LONG_OPTIONS,"
        LONG_OPTIONS="$LONG_OPTIONS${!OPT}"
    done
    for OPT in ${!LOPTA_*}; do 
        [ "$LONG_OPTIONS_ARG" ] && LONG_OPTIONS_ARG="$LONG_OPTIONS_ARG,"
        LONG_OPTIONS_ARG="$LONG_OPTIONS_ARG${!OPT}:"
    done

    [ "$STOP_ON_FIRST_NON_OPT" ] && STOP_EARLY="+"
    if [ "$__PG_LONG_GETOPT" ]; then
        local SHORT_ARGS=""
        local LONG_ARGS=""
        [ -n "$SHORT_OPTIONS$SHORT_OPTIONS_ARG" ] && SHORT_ARGS="-o $STOP_EARLY$SHORT_OPTIONS$SHORT_OPTIONS_ARG"
        [ -n "$LONG_OPTIONS" ] && LONG_ARGS="--long $LONG_OPTIONS"
        [ -n "$LONG_OPTIONS_ARG" ] && LONG_ARGS="$LONG_ARGS --long $LONG_OPTIONS_ARG"
        TEMP=$(getopt $SHORT_ARGS $LONG_ARGS -n "$PROG" -- "$@") || exit 1
    else
        TEMP=$(getopt $SHORT_OPTIONS$SHORT_OPTIONS_ARG "$@") || exit 1
    fi
    
    echo "$TEMP"
}

print_opt() {
    local _PG_NAME="$1"
    local L
    local N
    local _PG_DESC
    local SOPT
    local LOPT
    local SARG
    local LARG

    _PG_DESC=$(get_opt_desc $_PG_NAME)
    [ "$_PG_DESC" ] || return 0
    SOPT=$(get_opt_letter $_PG_NAME)
    LOPT=$(get_opt_string $_PG_NAME)
    SARG=$(get_opt_sarg $_PG_NAME)
    LARG=$(get_opt_larg $_PG_NAME)

    LINE=""
    for (( N=0 ; ${#LINE} < __PG_SHORT_OPT_COL ; N++ )) ; do LINE="$LINE " ; done
    [ "$SOPT" ] && LINE="${LINE}-$SOPT"
    [ "$SOPT" ] && [ "$SARG" ] && LINE="${LINE} $SARG"
    if [ "$__PG_LONG_GETOPT" ]; then
        [ "$SOPT" ] && [ "$LOPT" ] && LINE="$LINE, "
        if [ "$LOPT" ]; then
            [ "$SOPT" ] && LONG_START=${LONG_COL_OPT:-""} || LONG_START=$__PG_SHORT_OPT_COL
            for (( N=0 ; ${#LINE} < LONG_START ; N++ )); do 
                LINE="$LINE "
            done
            [ "$LOPT" ] && LINE="${LINE}--$LOPT"
            [ "$LOPT" ] && [ "$LARG" ] && LINE="$LINE=$LARG"
        fi
    fi
    LINE="$LINE "
    while (( ${#LINE} < _PG_OPT_DOC_COL - 1)) ; do LINE="$LINE " ; done
    # NB 'echo "-E"' swallows the -E!! and it has no -- so use printf
    printf -- "%s" "$LINE"
    
    FIRST="FIRST_yes"
    if (( ${#LINE} >= _PG_OPT_DOC_COL )); then
        echo
        FIRST=""
    fi
    local WIDTH=$(( __PG_RMARGIN - _PG_OPT_DOC_COL ))
    if ! type fmt &> /dev/null || [ "$WIDTH" -lt 10 ]; then
        printf -- "%s\n" "$_PG_DESC"
        return 0
    fi

    export __PG_INDENT=""
    while (( ${#__PG_INDENT} < _PG_OPT_DOC_COL - 1)); do __PG_INDENT="$__PG_INDENT "; done
    echo "$_PG_DESC" |fmt -w "$WIDTH" -s | { 
        while read L; do 
            [ "$FIRST" ] || 
            echo -n "$__PG_INDENT"; FIRST=""; printf -- "%s\n" "$L"
        done 
    }
    unset __PG_INDENT
}

# honour GNU ARGP_HELP_FMT parameter
load_help_fmt() {
    [ "${ARGP_HELP_FMT:-""}" ] || return 0
    OFS="$IFS"
    IFS=','
    set -- $ARGP_HELP_FMT
    IFS="$OFS"
    while [ "$1" ]; do
        case "$1" in
            short-opt-col*)
                __PG_SHORT_OPT_COL=$(echo "$1"|cut -d'=' -f 2)
                shift
                ;;
            long-opt-col*)
                __PG_LONG_OPT_COL=$(echo "$1"|cut -d'=' -f 2)
                shift
                ;;
            opt-doc-col*)
                _PG_OPT_DOC_COL=$(echo "$1"|cut -d'=' -f 2)
                shift
                ;;
            rmargin*)
                __PG_RMARGIN=$(echo "$1"|cut -d'=' -f 2)
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
}

default_usage() {
    local FLAGS=$(print_short_flags)
    [ "$FLAGS" ] && FLAGS="[-$FLAGS]"
    local LFLAGS=$(print_long_flags)
    [ "$LFLAGS" ] && LFLAGS=" [$LFLAGS]"
    local ARGS=$(print_all_args)
    local FMT="fmt -w $__PG_COLUMNS -s"
    type fmt &> /dev/null || FMT=cat
    echo "Usage: $PROG $FLAGS$LFLAGS$ARGS ${ARGUMENTS:-""}" |$FMT
    echo
    echo "${SHORT_DESC:-""}${USAGE:-""}" |$FMT
    echo
    echo "Options:"
    print_all_opts
}

check_type_and_value() {
	local VALUE="$1"
	local _PG_TYPE="$2"
	local _PG_RANGE="$3"

	# just using 'while' for the sake of the 'break':
	while [ "$_PG_TYPE" ]; do
		case "$_PG_TYPE" in
			i|I)
				echo "$VALUE" | egrep -q "$_PG_INT_REGEX" || break
				[ "x$_PG_RANGE" = x ] || {
					local LOWER=$(echo "$_PG_RANGE" | cut -d- -f1)
					local UPPER=$(echo "$_PG_RANGE" | cut -d- -f2)
					[[ "$LOWER" && "$VALUE" -lt "$LOWER" ]] && break
					[[ "$UPPER" && "$VALUE" -gt "$UPPER" ]] && break
				}
				return 0
				;;
			r|R|f|F)
				echo "$VALUE" | egrep -q "$FLOAT_REGEX" || break
				[ "x$_PG_RANGE" = x ] || {
					local LOWER=$(echo "$_PG_RANGE" | cut -d- -f1)
					local UPPER=$(echo "$_PG_RANGE" | cut -d- -f2)
					[ "$LOWER" ] && {
						awk "BEGIN {if ($VALUE < $LOWER) {exit 1} else {exit 0}}" || break
					}
					[ "$UPPER" ] && {
						awk "BEGIN {if ($VALUE > $UPPER) {exit 1} else {exit 0}}" || break
					}
				}
				return 0
				;;
			s|S)
				[ "x$_PG_RANGE" = x ] || {
					echo "$VALUE" | egrep -q "$_PG_RANGE" || break
				}
				return 0
				;;
			a|A)
				local VAL
				for VAL in $_PG_RANGE; do
					[ "$VAL" = "$VALUE" ] && return 0
				done
				break
				;;
		esac
	done

	(
		echo -n "$PROG: value '$VALUE' given for option '$_PG_NAME' must be of type '$_PG_TYPE'"
		[ "x$_PG_RANGE" = x ] || {
			case "$_PG_TYPE" in
				s|S)
					echo -n " and must fit REGEX '$_PG_RANGE'"
					;;
				a|A)
					echo -n " and must be one of these values: $_PG_RANGE"
					;;
				i|I|f|F) echo -n " and in range '$_PG_RANGE'"
					;;
			esac
		}
		echo
	) | fmt >&2
	exit 1
}
    
process_opts() {
    local SHIFT_NUM=0
    while true; do
        case "${1:-""}" in
        -$HELP_option | --$HELP_loption) 
            usage 2>/dev/null || default_usage
            exit 0
            ;;

        -$VERSION_option | --$VERSION_loption) 
            echo "$PROG: version $VERSION"
            exit 0 
            ;;

        -$VERBOSE_option | --$VERBOSE_loption) 
            VERBOSE="VERBOSE_yes"
            ((SHIFT_NUM++))
            shift
            ;;

        -$QUIET_option | --$QUIET_loption) 
            VERBOSE=""
            ((SHIFT_NUM++))
            shift
            ;;

        --$PRINTMAN_loption)
            print_man_page
            exit 0
            ;;

        --)
            ((SHIFT_NUM++))
            break
            ;;
            
        *) 
            local _PG_NAME=$(get_opt_name "$1")
            if [ -z "$_PG_NAME" ]; then
                echo "$PROG: process-getopt: process_opts: no function for option \"$1\"" >&2
                exit 1
            fi

			local _PG_TYPE=$(get_opt_type "$_PG_NAME")
			[ "$_PG_TYPE" ] && {
				local VALUE="$2"
				local _PG_RANGE=$(get_opt_range "$_PG_NAME")
				check_type_and_value "$2" "$_PG_TYPE" "$_PG_RANGE"
			}
            $_PG_NAME$FUNC_SUFFIX "$1" "$2"; local STAT=$?
            shift
            ((SHIFT_NUM++))
            [ "$STAT" -eq 127 ] && exit 0 # no such function
            
            # now let's adjust for options with args:
            local SA="ARG_SOPTA_$_PG_NAME"
            local LA="ARG_LOPTA_$_PG_NAME"
            if [ "${!SA:-""}${!LA:-""}" ]; then
                shift
                ((SHIFT_NUM++))
            fi
            ;;
        esac
    done
    return $SHIFT_NUM
}

get_opt_name() {
    # returns the name for an option letter or word
    local OPT="$1" # an option eg -c or --foobar
    local _PG_NAME
    for _PG_NAME in $__PG_OPTION_LIST; do 
        local L=LOPT_$_PG_NAME
        local LA=LOPTA_$_PG_NAME
        local S=SOPT_$_PG_NAME
        local SA=SOPTA_$_PG_NAME
        if  [ "--${!L:-""}" = "$OPT" ] || \
            [ "--${!LA:-""}" = "$OPT" ] || \
            [ "-${!S:-""}" = "$OPT" ] || \
            [ "-${!SA:-""}" = "$OPT" ]; then
            echo "${_PG_NAME}"
            return 0
        fi
    done
    return 1
}

__PG_VERSION="2.0"
__PG_STANDALONE=""
STOP_ON_FIRST_NON_OPT=${STOP_ON_FIRST_NON_OPT:-""}
# First some safety checks:
[ "$PROG" ] || { 
    PROG=$(basename $0)
    if [ "$PROG" != "process-getopt" ]; then
        echo "$PROG: process-getopt: \$PROG not defined, bailing" >&2; 
        exit 1; 
    fi
    # Otherwise, we're running as a standalone - perhaps to get the
    # version or help
    VERSION=$__PG_VERSION
    usage() { process_getopt_usage; }
    __PG_STANDALONE="__PG_STANDALONE_yes"
}

[ "$VERSION" ] || { 
    echo "$PROG: process-getopt: \$VERSION not defined, bailing" >&2 
    exit 1
}

__PG_COLUMNS=`tput cols 2>/dev/null` || __PG_COLUMNS=80
((__PG_COLUMNS--))

__PG_OPTION_LIST=""
__PG_LONG_GETOPT=""
# decide if this getopt supports long options:
{ 
    getopt --test &>/dev/null; __PG_STAT=$? 
} || : 
[ $__PG_STAT -eq 4 ] && __PG_LONG_GETOPT="__PG_LONG_GETOPT_yes"

HELP_loption="help"
HELP_option="h"
VERBOSE_loption="verbose"
VERBOSE_option="v"
QUIET_option="q"
QUIET_loption="quiet"
VERSION_loption="version"
VERSION_option="V"
PRINTMAN_loption="print-man-page"
FUNC_SUFFIX="_func"

__PG_SHORT_OPT_COL=2
__PG_LONG_OPT_COL=6
_PG_OPT_DOC_COL=29
__PG_RMARGIN=79

_PG_INT_REGEX="[+-]*[[:digit:]]+"
_PG_INT_RANGE_REGEX="$_PG_INT_REGEX-$_PG_INT_REGEX"
_PG_FLOAT_REGEX="[+-]*[[:digit:]]+(\\.[[:digit:]]+)*"
_PG_FLOAT_RANGE_REGEX="$_PG_FLOAT_REGEX-$_PG_FLOAT_REGEX"
# FIXME: this needs a few tweaks:
_PG_URL_REGEX="(nfs|http|https|ftp|file)://[[:alnum:]_.-]*/[^[:space:]]*"

# stubs to satisfy add_opt on standard opts:
HELP_func() { :; }
VERBOSE_func() { :; }
QUIET_func() { :; }
VERSION_func() { :; }
PRINT_MAN_PAGE_func() { :; }
END_OPTIONS_func() { :; }

load_help_fmt

[ "$__PG_RMARGIN" -gt "$__PG_COLUMNS" ] && __PG_RMARGIN=$__PG_COLUMNS

# normally, this is called without args - but we can also respond to
# normal options too!
[ "$__PG_STANDALONE" ] && {
    add_std_opts
    TEMP=$(call_getopt "$@") || exit 1
    eval set -- "$TEMP"
    process_opts "$@"
    shift "$?"
}

# just to make sure we don't return with non-zero $?:
:
